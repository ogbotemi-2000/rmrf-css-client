
let script = d.createElement('script');
  script.src="../js/email.min.js", script.id='loadEmail',
  window.emailjs?(emailjs.init("mP1S96NaJfOO3FpUR"), emailjsInited=false):(emailjsInited=true, d.head.append(script));

_____

window.onerror = function(e) {
  alert('::ERROR:: '+ e)
},
page={
  retry:function(t,o){
    page.done.reset&&page.done.reset()/*call defined functions before reset*/,
    qs('[contenteditable]').contentEditable=true,

/*Object.freeze prevent properties from being added to an object but
it fails to account for functions that are treated as object by defining properties on their name.
Doing what Object.freeze should have considered - preventing properties from being defined on functions and deleting them if they are
*/
['done', 'fetch_readScripts'].forEach(fn_name=>{
  fn_name = this.template[fn_name];
  for(let i in fn_name) typeof fn_name[i]!=='function'&&!/name|length/.test(i)&&delete fn_name[i];
}),

    o=objWalk, t=this.template, page = {};
    for(let i in t) page[i] = t[i];
    page.template=t,
    qsa('section>section .tooltip.show').forEach((e, cls, flag)=>{
      (cls=e.classList).contains('absolute')?cls.remove('show'):cls.replace('show', 'absolute'),
      cls.remove('sm:h-96', 'from-yellow-300')
    }), qsa('section>section').forEach(e=>e.classList.toggle('show')),
    o(notify, 'fEC').className='', o(retry, 'cL').remove('show'),
    trigger.lastChild.data='start', qsa('[disabled]').forEach(e=>e.removeAttribute('disabled'))
  },
  clone:function(){
    if(!this.template) for(let prop in this) (this.template||={})[prop]=this[prop];
    Object.freeze(this.template)
  },
  mobile: function() {return /android|ip(hone|ad)/i.test(this.uA)},
  endIp: _=>location.hostname==='localhost'?'http://localhost':'https://remcss.up.railway.app',
  uA: navigator.userAgent,
  detectAttrs: function(classes, flag, o, i, done) {
    i||=0, setTimeout(_=>_=setInterval(n=>{
      i>=classes.length&&(o(notify,['lEC', 'cL'])[flag?'add':'remove']('to-fro', 'border-2'), clearInterval(_), setTimeout(_=>qs('.__class__').querySelector('input').focus()),
      !flag&&(o(notify, 'fEC').textContent='Press enter to continue. Input other attributes that do not end with `class` or `id` and, that equal CSS selectors to add them to the found selectors'),
      done&&done()),
      qs('.__class__').querySelector('code').textContent = i +' selectors found', ++i
    }))
  },
  gen:length=>Array.from({length}),
  fetch_readScripts: function(ctx, out, hr, o, onload, onerror, request, lat=2000, cls, xhr, srcs, els, t, write, url=page.url) {
    t=this.fetch_readScripts, t.gen=_=>this.gen(srcs.length), w.scrollTo(0, d.body.scrollHeight*0.5), els = filter(o(qs('.__class__'), 'nES').querySelector('h4+div').children, (_,i)=>!(i%2)),
    srcs=this.assets.js, xhr=t.sync||=new XMLHttpRequest, t.async ||=t.gen().map(_=>new XMLHttpRequest),
    t.failed||=0, t.count||=0, t.strings||=t.gen(), t.responses||=t.gen(), t.sentCount ||=0,
    
    t.abort=arg=>(arg.abort(), ['load', 'error'].forEach(e=>arg['on'+e]=null)), t.scriptStrings||=[],
    t.getStrings=(arr, res, loop)=>{
      if(!res) return;
      for(let i=0, str, jump, nxt, cmt, len=res.length, tst=n=>/`|'|"/.test(res.charAt(n)), e; e=res.charAt(i), i<len;) {
        if(e==='/'&&/\/|\*/.test(nxt=res.charAt(i+1))) cmt=loop(res, {from:i, cb:(s,f,e)=>{
          return nxt==='/' ? s[f-1]==='\n': (s[f-2]+s[f-1]==='*/')
        }}), cmt[1]&&(i=cmt[1]+1) /*jump over comments*/;

        tst(i)&&(jump = loop(res, {from:i+1, cb:(s,f)=>tst(f)}), jump[1]>i&&(i=jump[1], 
        /*validate as selector*/ str = jump[0].trim(), str.length>1&&!/@|;|\||\\|^(\[|\]|;|\/|-|_)|\?|\{|\}|\%|\/\/|=|\!|\&|\+|>|<|(\/|-|_|:|\[|\])$|\*|\(|\)|\.|\$|\s/g.test(str)&&!page.classes.find(e=>e===str)&&!t.scriptStrings.find(e=>e===str)&&[arr, t.scriptStrings].forEach(e=>e.push(str))
        ), i+=2/*+2 to make i point to the character after the closing apostrophe*/), i++
      }
    },

    onload = function(e, i, fromCDN, tgt, st, res, bool, arr) {
      ++t.count, res=(tgt=e.target).response, st=tgt.status+'', bool=(/^(1|2)/.test(st.charAt(0))||304==st),
      t.failed+=!bool, bool&&(t.responses[i]=res, !fromCDN&&t.getStrings(t.strings[i]||=[], res, both.loop)),

      els[i].classList.add('bg-'+(bool?'green':'red')+'-200'), t.write()
    }, onerror=function(e, i, bool) {
      ++t.failed, t.write(t.count+=true), els[i]&&els[i].classList.add('bg-red-200')
    },
    /*lat represents the time delay required to make the user have a time to act on the page choices for concurrent requests */
    /*the setTimeout delay in "request" is needed to prevent the browser from dropping the incoming response for the first request in favour of making the current one*/
    request=_=>setTimeout(_=>{xhr.open('GET', srcs[t.count].match(/^(http|www)/)?srcs[t.count]:this.domain+srcs[t.count]), setTimeout(_=>xhr.send(), lat)}),
    t.go=flag=>{/*nf stands for not fetched, it points to the numnber of empty elements in resources*/
      if(t.simultaneous=flag) !t.responses[t.sentCount]&&t.abort(xhr), t.async.slice(t.sentCount).forEach((e, i, src, fromCDN)=>{ (src=srcs[i+=t.sentCount])&&(e.open('GET', /^(http|www)/.test(src)?(fromCDN=!0, src):this.domain+src), e.onload=ev=>onload(ev, i, fromCDN), e.onerror=ev=>onerror(ev, i), e.send()) });
      else xhr.onerror=ev=>{ ++t.sentCount, t.count<(srcs.length-1)&&request(), onerror(ev, t.count) }, xhr.onload=ev=>{ ++t.sentCount, !t.simultaneous&&t.count<(srcs.length-1)&&request(), onload(ev, t.count) }, request();
    },
    cls=bool=>{o(ctx, 'cL')[bool?'add':'remove']('stroked-light-border'), hr[bool?'remove':'add']('to-fro', 'border-2')},
    t.afterFetch_read =(sib, matched, len=t.strings.length)=> {
      this.scripts.forEach((e, i)=>t.getStrings(t.strings[len+i]||=[], e, both.loop)), sib=o(ctx, 'nES'),
      /*enforce that either a whitespace or a quote should flank each string by wanting the matches to equal 2*/
      // (matched=t.scriptStrings.filter((e, m)=>(m=this.html.match(e))&&[-1, m[0].length].map(i=>/\s|("|')/g.test(this.html.charAt(m.index+i))).filter(e=>e).length===2))&&
      matched=t.scriptStrings,
      setTimeout(lEC=>{
        (lEC=o(sib, 'lEC')).innerHTML=matched.join('&nbsp; • &nbsp;'), o(sib, 'cL').replace('absolute', 'show'), hr.remove('border-2', 'to-fro'),
        out.innerHTML = `Likely CSS selectors matched in the scripts.<br>You may further remove or add to the content of the entry box above and be "done ?" <p class='inline-block'>(pun intended, ^_^)</p>.<br>Filtered out <a class='border-b border-current align-bottom ripple p-1 relative pb-0 inline-block'>impossible selector strings</a> as well as strings from scripts fetched from domains different from <code class='font-semibold'>${this.domain}</code>`,
        w.scrollTo(0, d.body.scrollHeight*0.5), setTimeout(_=>lEC.focus(), 120)
      }, t.failed?3500:500)
    },
    !/Firefox/i.test(this.uA)&&cls(true),
    setTimeout(_=>{
      /* uncomment to enforce async requests of scripts - t.simultaneous=true, */
      (t.write=(failed, init, i=t.count, bool=t.count<srcs.length-1, diff=srcs.length-t.count, plu=diff?'':'s')=>{out.innerHTML=t.count<srcs.length?(`Fetching data for <code class='font-semibold'>`+(t.simultaneous?`${diff=t.responses.length-t.sentCount}</code> script${diff===1?'':'s'}`:`${diff}</code> external script${diff===1?'':'s'}
        ${bool?'<div class="mb-2 inline-block [&>*]:p-2" onclick=\'let t=event.target; forEach(this.children, e=>e.classList[t===e?"add":"remove"]("border-2"))\'><button class="ripple relative rounded-l-lg border-2 border-r-2 border-gray-400 hover:bg-gray-200">concurrently</button><button onclick=\'let t=page.fetch_readScripts; t.go(!0) \' class="hover:bg-gray-200 ripple relative rounded-r-lg border-l-2 border-gray-400">simultaneously</button></div>'
        :''}<br>Click <button class='mx-1 border-2 relative border-gray-600 rounded-lg p-2 ripple px-4' onclick="page.fetch_readScripts.write()">abort</button> to ${bool?'move to the next script if you\'re certain that':'cancel fetching'} <code class='font-semibold'>${srcs[i]}</code>${bool?' doesn\'t access the DOM or mutate it':''}`))
        :(t.afterFetch_read(),
        cls(false), `Fetched ${t.failed?'':'all'} ${diff=srcs.length-t.failed} script${diff===1?'':'s'}, ${t.failed?'the server either denied access to or doesn\'t have '+ (t.failed<srcs.length?t.failed:'all the') +' requested script'+(t.failed===1?'':'s')+'.<p class="mb-4 text-gray-900">A <a class="inline-block ripple bg-blue-100 align-middle mx-1 rounded ripple relative px-3 p-1">workaround<i class="ml-2 fa fa-external-link-alt"></i></a> for the fetching the failed scripts will be added as this service gains support from its users, grows and evolves....</p>P':'p'}roceeding to show the strings matched in both the inline script(s) and/or ${t.failed?'what\'s left of':''} the fetched scripts(s)...`),
        animations.addRippleAnimations()})()
      /*passing true to t.go beside makes an asynchronous request*/t.go(/*uncomment for async- true*/)
    }, 2500/*200*/)
  },
  done: function(txt, o, btn, strs, t, _o, from, out, len, cb) {
    writeCSS.children[0].querySelector('pre').textContent='used CSS styles', trigger.removeAttribute('disabled'), t=this.done;
    /*the checks involving _o below are to ensure that the codes they are for are executed when done is called the designated in the flow of the app*/
    if(_o=o) o(notify, ['lEC', 'cL']).add('to-fro', 'border-2'), (strs=o(btn, ['pN', 'nES'])).innerHTML=`<i class='text-sm'>• added the strings to the found CSS selectors. •</i>`, txt=txt.replace(/•/g, '').replace(/\s+/g, ' ').split(' ').filter(e=>e), btn.textContent='done',  o(btn, ['pES','cL']).add('hidden'), btn.disabled=true,
      ['disabled', 'contenteditable'].forEach(attr=>strs.setAttribute(attr, false)), strs.blur(),  from=page.classes.length, qs('section>aside').classList.add('from-yellow-300'),
      txts=['ing', 'ed'].map(e=>`Add${e} the ${txt.length} extra string${txt.length==1?'':'s'} in the input field above to the number of found selectors`),
      cb=_=>{o(notify, ['lEC', 'cL']).remove('to-fro', 'border-2'), o(notify, ['pN', 'nES', 'cL']).replace('absolute', 'show'), t.prepare(o), w.scrollTo(0, d.body.scrollHeight),
        out.innerText = `${len?txts[1]:'No strings matched or provided in the input box above'}.\nBeginning what you are here for - extracting used styles from all the CSS files using the ${page.classes.length} found selectors`,
	setTimeout(_=>trigger.focus(), 100);
      },
      out=o(notify, 'fEC'), (len=txt.length)&&(out.textContent = txts[0]+'...', this.detectAttrs(page.classes=page.classes.concat(txt), true, o, from, _=>setTimeout(cb, 1500))),
      !len&&setTimeout(_=>cb(len), 500)

    t.least=t.count=0, t.files=[],
    t.download=(index, blob, name, names, ext)=>{
	names=['matched', 'unmatched', 'used', 'unused'], ext=index>1?'txt':'css',
        name = (name=page.assets.css[t.count])?name.split('/').pop().replace('.css', ''):'file',
	name+='--'+names[index]+'.'+ext, blob = new Blob([t.files[index]], {type:`text/${ext}`}),
	save(blob, name, !index)
    },
    t.prepare=(o, fetched_css, html='', fetched, all, nES, arr=['show', 'absolute'], css)=>{
      fetched_css=t.fetched_css||=fetched_css||[];
      if(_o) {
        all=this.inlineStyles.concat(t.fetched_css.filter(e=>e)), css=this.assets.css,
        /*increment count to jump over the absent css assets when matching used classnames*/
        fetched_css.forEach((e,i)=>{html+=`<div class='font-bookweb ${e?'border border-gray-400 ':(t.least=++t.count, 'bg-red-200 ')}truncate mr-4' style='max-width:18rem;'>${e?'<hr style="--tw-bg-opacity:0.7; --tw-translate-x:-100%" class="border-0 transform bg-green-200 h-full absolute inset-0 -left-2 -right-2">':''}<span class="relative">${css[i]}</span></div>`}),
        (this.inlineStyles||[]).forEach((e, i)=>html+=`<div class='font-bookweb truncate mr-4 border border-gray-400' style='max-width:18rem;'><hr style='--tw-bg-opacity:0.7; --tw-translate-x:-100%' class="transform border-0 h-full absolute inset-0 bg-green-200 -left-2 -right-2"><span class="relative">${e}</span></div>`),

        o(ctx=o(notify, ['pN', 'nES']).querySelector('section'), 'pES').textContent = `Scanning stylesheets (${all.length})`,
        /*populate the div bearing the stylesheets for the next section here while indicating unfetched external stylesheets by using red colour*/
        (nES=o(ctx, 'nES')).innerHTML = html, [ctx, nES].forEach((e, i)=>arr.forEach(cls=>o(e, 'cL').toggle(cls))),
        this.styles = t.fetched_css.concat(this.styles), o(writeCSS, 'cL').replace('absolute', 'show'), o(writeCSS, 'cL').add('sm:h-48'),
        t.all=this.styles.length
      }
      t.reset=(ctx, cls)=>{
        trimCSS.reset(), /*add a little delay for when progress below is called after done*/
	setTimeout(_=>forEach(writeCSS.children, e=>e.firstElementChild.textContent=''), 60),
	forEach(nES.querySelectorAll('.'+(cls='bg-yellow-200')), e=>o(e,'cL').remove(cls))
      },
      t.begin=(trigger, n, ctx, outs, format)=>{
	t.interval=setTimeout(_=>{setTimeout(_=>w.scrollTo(0, d.body.scrollHeight*w.innerWidth/640), 280), o(trigger, ['nES','cL']).replace('absolute', 'show')}, 3000),
	t.count===t.all&&(t.count=t.least), 
	outs=[0, 1].map(i=>o(writeCSS.children[i], 'fEC')), o(ctx=nES.children[n=t.count], 'cL').add('bg-yellow-200'),
        format=str=>str.replace(/\{/g, e=>'\t'+e+'\n').replace(/,/g, e=>e+`\t`).replace(/\}/g, e=>'\n'+e).replace(/\;/g, e=>e+'\n'),
        trimCSS(page.styles, page.classes, /*progress*/function(arr, used, i, tot, frameId, ratio, frmt){
	  o(retry, 'cL').remove('show'), t.files=[], o(downloadCSS, 'cL').replace('show', 'absolute'), trigger.disabled=true, outs.forEach((e, i)=>{
            e.innerText = arr[i], setTimeout(_=>e.scrollTop = e.scrollHeight, 2000)
          }), o(outs[0], 'nES').textContent = `used ${both.byteFormat(used.length)} out of ${both.byteFormat(tot)}`,
	  ratio=100*i/tot, o(ctx, 'fEC').style.setProperty('--tw-translate-x', -100+Math.round(ratio)+'%')
        }, /*done*/function(i, tot, arr, classes, thresheld, reset, ratio) {
     	  if(!reset) o(trigger, ['nES','cL']).replace('show', 'absolute'), o(retry, 'cL').add('show'), clearTimeout(t.interval), o(trigger, 'lC').data='done, continue',
	    o(ctx, 'fEC').style.setProperty('--tw-translate-x', -100+Math.round(ratio)+'%'),
	    o(downloadCSS, 'cL').replace('absolute', 'show'), outs.forEach((e, i, txt)=>{t.files[i]=txt=arr[i], !thresheld&&(e.innerText = txt)}), 
	    classes.forEach((e, i)=>t.files[i+2]=e);
	  trigger.removeAttribute('disabled'), 
          o(outs[0], 'nES').textContent = `used styles of size ${both.byteFormat(arr[0].length)} out of ${both.byteFormat(tot)}`
        }, n)
      }
    };
      
    /*the returned value is used to call the desired method defined on this function*/
    return t;
  },
  continue:function(txt, rgx, o=objWalk, classes, out, hr, ctx) {
    out=o(notify, 'fEC'), hr=o(notify,['lEC','cL']), hr.add('border-2', 'to-fro');
    if(txt&&(txt=txt.split(' ').filter(e=>e!=='class'&&e!=='id').map(e=>e.trim())).length) {
      rgx=txt.join('|'), rgx=[`)=('|")[^("|')]+('|")`, `)=|"`].map(e=>new RegExp('('+rgx+e, 'g')),

      out.innerHTML=`Detecting CSS classes present in ${txt.map(e=>"<code class='font-semibold'>"+e+'</code>').join(', ')} attributes in the fetched document`,
      (classes=both.getAttrs(this.html, rgx, each=>!~page.classes.indexOf(each)&&page.classes.push(each))).length
      ? (this.detectAttrs(classes, false, o, this.classes.length, _=>(out.textContent=`Found ${classes.length} extra CSS selector${classes.length===1?'':'s'}, preparing to find more strings in document\'s scripts` )))
      : out.textContent='FYI: No new CSS selectors were found, proceeding to interactively find strings in the document\'s scripts'
    } else {
      out.textContent = 'No new attributes were provided, continuing with an alternative of finding strings in the document\'s scripts instead'
    }
    (ctx=o(o(notify, {2:'pN'}).querySelector('.__class__'), ['nES'])).classList.replace('absolute', 'show'), setTimeout(_=>this.fetch_readScripts(ctx, out, hr, o), 300)
  },
  
  get: function(url, t, xhr=new XMLHttpRequest, endp, prot='', onerror, root, index, out, hr, assets, arr, o=objWalk, pN, splits, split) {
    if(this.gotten) return;
    onerror=txt=>{out.innerText=txt||assets.error, out.classList.add('text-red-600'), hr.remove('to-fro', 'border-2'), o(notify, 'cL').add('w-full'), o(retry, 'cL').add('show')},
    this.gotten=!0/*to prevent multiple calls of this function when the url is entered in the input field.
    While it causes no errors if this happens, the side-effect of having linked assets details written to the DOM more than once is not desirable
    */
    endp=this.endIp(), prot = (prot=url.match(/^http[a-z]*:\/\//g))?prot[0]:'http://',
    url=url.split('//'), url.length>1&&url.shift(), root=url[0].slice(0, ~(index=url[0].indexOf('/'))?index:url[0].length)+'/', this.domain = prot+root,
    // (prot=url.match(/^http[a-z]*:\/\//g))?root=url.replace(prot=prot[0], '').split('/').shift():(prot='http://', root=url.split('/').shift(), url=prot+url),
    setTimeout(_=>{o(_=qs('section>section'), 'cL').add('show'), o(_, ['nES', 'cL']).remove('show')}, 200), page.url = url=url=url.length===1?prot+url:url.join('//')
    qs('section>article>code').textContent=url?'[URL]:: '+url:'[File Upload]:: '+(arr=slice(file.files).map(e=>e.name)).join(', '),
    console.log('::URL::', url, this.domain),

    (out=o(notify, 'fEC')).textContent=url?'uploading url and fetching the resource it points to on the server for processing ':`fetching scripts to process the chosen file${'s'.repeat(!!--arr.length)} on the client`,
    hr=o(notify, ['lEC', 'cL']);

    if(url) hr.add('to-fro', 'border-2'), xhr.open('GET', endp+'/?url='+url), xhr.send(), xhr.onerror=e=>onerror('::[CONNECTION ERROR]:: The server was unreached - you may be offline'), xhr.onload=(ev, res, pI, json, aside)=>{
        (res=ev.target.response).charAt(0)==='_'
        &&(this.splits=res.slice(0, pI=res.indexOf('|')).split(','), res=res.slice(pI+1)),
        this.splits&&(split=res.split((splits=page.splits)[0])),

        aside=o(notify, {2:'pN'}).querySelector('aside'),
        (json=res.charAt(0)==='{')&&(this.assets = assets = JSON.parse(split?split[0]:res), split&&(page.html=split[1]));
        if(!assets.error) {
          /*the if below handles response for the second request*/
        if(!json) {
          let classes = split[0].split(',').filter(e=>e), asides=[o(aside, {2:'nES'}), aside],
          rgxes=[/script/g, /style/g], p=aside.querySelector('p'), inline=o(p, 'nES');

          classes.length?(page.classes=classes, this.detectAttrs(classes, false, o), o(qs('.__class__'), 'cL').replace('absolute', 'show'))
          : (out.textContent='No attribute that equals CSS classes is present in this resource', hr.remove('to-fro', 'border-2'),
	    ['show', 'absolute'].forEach(e=>o(retry, 'cL').toggle(e))),
	  /*clear all HTML showing details of inline assets*/		
	  asides.forEach(aside=>o(aside.querySelector('p'), 'nES').innerHTML=''),
          split[1].split(splits[1]).forEach((e, i, a)=>{
            [/^script/, /^style/].forEach((rgx, _i, ast)=>{
              ast = rgx.toString().replace(/\^|\//g, '')
              _i===0&&(page.hasScript||=_i),
              e.match(rgx)&&((page[ast+'s']||=[]).push(a[i+1]), p=asides[_i].querySelector('p'), (inline=o(p, 'nES')).innerHTML||='',
              inline.innerHTML+=`<span class="p-0.5 px-2.5 border-transparent border-2 hover:border-current font-bookweb text-base mr-3 my-2">${(_i&&(this.inlineStyles||=[]).push(e), e)}<code class='text-black inline-block text-xs'>&nbsp;•&nbsp;${both.byteFormat(a[i+1].length)}</code></span>|`)
            })
          }),
          asides.forEach((el, il)=>(il=el.querySelector('p+div')).innerHTML=il.innerHTML.replace(/\|$/,'')),
          setTimeout(_=>rgxes.forEach((e, i, prop, p, inline, len)=>{
            prop=(e+'').replace(/\/|g/g, ''), p=asides[i].querySelector('p'), inline=o(p, 'nES'),
            p.textContent=inline.innerHTML?(o(inline, 'cL').replace('absolute', 'show'), `[ ${len=inline.innerHTML.match(e).length} ] Inline ${prop+(len?'s':'')} present`)
            :`No inline ${prop+(len?'s':'')} detected`, w.scrollTo(0, d.body.scrollHeight)
          }), 800)
        } else {
          let sort=[], css=assets.css, title, count=0, css_out=o(notify, ['pN', 'nES']).querySelector('section'), fetched_css=[],
          done=(res, bool, i)=>{sort.push(css[i]), fetched_css.push(res), o(css_out.children[i], ['fEC', 'cL']).remove('to-fro', 'bg-blue-200'),
	   bool&&(css_out.innerHTML=``, setTimeout(_=>o(css_out, 'cL').replace('show', 'absolute'), 60), this.assets.css=sort, this.done().prepare(o, fetched_css))};

          o(css_out, 'pES').textContent=`Fetching linked stylesheet (${css.length})`, css_out.innerHTML='',
          this.gen(css.length).map(e=>new XMLHttpRequest).forEach((xhr, i, arr, url)=>{
            css_out.innerHTML+=`<div class='truncate mr-4' style='max-width:18rem;'><hr class="border-transparent h-full absolute to-fro border-0 inset-0 bg-blue-200"><span class="relative">${css[i]}</span></div>`,
            xhr.open('GET', this.domain+(url=css[i])), xhr.send(), xhr.onload=xhr.onerror=(ev, t, st)=>{st=(t=ev.target).status+'', done(!(st==304||/^(1|2)/g.test(st.charAt(0)))?'':ev.target.response, count++===arr.length-1, i)}
          }),
          (title=qs('article>div>code')).textContent = '• [TITLE]:: '+ assets.title,
          assets.icon&&(o(title, 'pES').src=assets.icon.match(/^(http|www)/)?assets.icon:this.domain+assets.icon);
          let props = ['css', 'js'], txt=['linked stylesheets', 'external scripts']; setTimeout(_=>o(aside, 'cL').replace('absolute', 'show'), 60), page.hasScript=assets.js.length,
          [aside, o(aside, {2:'nES'})].forEach((el, i, v)=>{
            /*min text length for the given font size and font is 40 on IPhone SE*/
            el.querySelector('h4+div').innerHTML = assets[v=props[i]].map(e=>`<span class="${e.length>40?'sm:w-full w-72 truncate ':''}p-1 px-3 text-black text-base font-bookweb">${e}</span>`).join('<hr class="inline-block mx-2 p-0.5 border border-current">'),
            out.innerHTML = `Detecting selectors present in <code class='font-semibold'>class</code>, <code class='font-semibold'>id</code> attributes in the fetched document`,
            el.querySelector('h4').textContent=(assets[v].length?'Found ':'No ')+txt[i]
          }),
          /*make a second request*/
          /*a timeout to prevent the browser from dropping the incoming response for the outgoing request above as it makes the delayed request below*/
          setTimeout(_=>{xhr.open('GET', endp+'/?url=__retrieve__&for='+url), setTimeout(_=>{xhr.send()})})
        };
        /*reset notify.classList*/
      } else onerror();
    }
  }
}
/*make a clone of page early on to make retries easier*/
page.clone()
        
_____
.stroked-light-border {/*--border-gradient-angle is specified from 0turn to 1turn in a keyframe, --runtime is for the colour of the stroke-light*/
            --runtime: #e07c17;
            background-image: conic-gradient(from var(--border-gradient-angle) at 50% 50%, transparent, var(--runtime) 14%, transparent 17%);
            animation: 2s linear 0ms infinite light-border;
            background-size: contain;
          }
          @keyframes light-border {
            0% {
              --border-gradient-angle: 0deg;
            }
            100% {
              --border-gradient-angle: 360deg;
            }
          }
          html {
            --border-gradient-angle:0deg;
          }
          @property --border-gradient-angle {
            syntax: "<angle>";
            inherits: true;
            initial-value: 360deg;
          }
        
_____

!emailjsInited&&emailjs.init("mP1S96NaJfOO3FpUR");

window.addEventListener('DOMContentLoaded', _=>{
  animations.addRippleAnimations()
})
